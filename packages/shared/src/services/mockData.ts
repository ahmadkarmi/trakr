import { User, UserRole, Audit, AuditStatus, Survey, Organization, Branch, Zone, LogEntry, QuestionType, AuditPhoto, AuditorAssignment, AuditFrequency, BranchManagerAssignment, AuditReviewLock, ApprovalAuthority, Notification, NotificationType } from '../types';

// Mock Organizations
export const mockOrganizations: Organization[] = [
  {
    id: 'org-1',
    name: 'Acme Corporation',
    description: 'Leading retail chain with multiple branches',
    timeZone: 'UTC',
    weekStartsOn: 1,
    gatingPolicy: 'completed_approved',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
];

// Mock Zones
export const mockZones: Zone[] = [
  {
    id: 'zone-1',
    orgId: 'org-1',
    name: 'North Region',
    description: 'Northern locations',
    branchIds: ['branch-1'],
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
];

// Mock Notifications
export const mockNotifications: Notification[] = [
  // When audits are dynamically created in SUBMITTED status without going through the submit flow,
  // we need to ensure notifications exist for branch managers
  // These will be auto-generated by the system when audits are submitted through the UI
]

// Mock Auditor Assignments
export const mockAuditorAssignments: AuditorAssignment[] = [
  {
    userId: 'user-1',
    branchIds: ['branch-1'],
    zoneIds: [],
  },
  {
    userId: 'user-10',
    branchIds: ['branch-2'],
    zoneIds: [],
  },
  {
    userId: 'user-11',
    branchIds: [],
    zoneIds: [],
  },
];

// Mock Branch Manager Assignments
export const mockBranchManagerAssignments: BranchManagerAssignment[] = [
  {
    id: 'bma-1',
    branchId: 'branch-1',
    managerId: 'user-2',
    assignedAt: new Date('2024-01-01'),
    assignedBy: 'user-3',
    isActive: true,
  },
  {
    id: 'bma-2',
    branchId: 'branch-2',
    managerId: 'user-2',
    assignedAt: new Date('2024-01-01'),
    assignedBy: 'user-3',
    isActive: true,
  },
  // Real Supabase branch manager assignments
  {
    id: 'bma-real-1',
    branchId: '46e396a0-ef75-43ea-9ce5-9c931f2d5282',
    managerId: '9fa9b8c1-45b6-45fe-81e6-efb429b6b6bd',
    assignedAt: new Date('2024-01-01'),
    assignedBy: 'admin',
    isActive: true,
  },
  {
    id: 'bma-real-2',
    branchId: 'e268b409-28a8-414d-9804-b8f37c74751f',
    managerId: '9fa9b8c1-45b6-45fe-81e6-efb429b6b6bd',
    assignedAt: new Date('2024-01-01'),
    assignedBy: 'admin',
    isActive: true,
  },
  {
    id: 'bma-real-3',
    branchId: '5251b122-ee38-43d0-b807-d496b33281f5',
    managerId: '9fa9b8c1-45b6-45fe-81e6-efb429b6b6bd',
    assignedAt: new Date('2024-01-01'),
    assignedBy: 'admin',
    isActive: true,
  },
];

// Mock Review Locks
export const mockReviewLocks: AuditReviewLock[] = [];

// Mock Branches
export const mockBranches: Branch[] = [
  {
    id: 'branch-1',
    name: 'Downtown Store',
    address: '123 Main St, Downtown',
    orgId: 'org-1',
    managerId: 'user-2',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  {
    id: 'branch-2',
    name: 'Mall Location',
    address: '456 Shopping Center Blvd',
    orgId: 'org-1',
    managerId: 'user-2',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
];

// Mock Users
export const mockUsers: User[] = [
  {
    id: 'user-1',
    name: 'John Auditor',
    email: 'auditor@trakr.com',
    role: UserRole.AUDITOR,
    orgId: 'org-1',
    branchId: 'branch-1',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  {
    id: 'user-10',
    name: 'Alice Auditor',
    email: 'alice@trakr.com',
    role: UserRole.AUDITOR,
    orgId: 'org-1',
    branchId: 'branch-2',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  {
    id: 'user-11',
    name: 'Bob Auditor',
    email: 'bob@trakr.com',
    role: UserRole.AUDITOR,
    orgId: 'org-1',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  {
    id: 'user-2',
    name: 'Jane Manager',
    email: 'manager@trakr.com',
    role: UserRole.BRANCH_MANAGER,
    orgId: 'org-1',
    branchId: 'branch-1',
    signatureUrl: undefined,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  {
    id: 'user-3',
    name: 'Admin User',
    email: 'admin@trakr.com',
    role: UserRole.ADMIN,
    orgId: 'org-1',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
];

// Mock Survey Templates
export const mockSurveys: Survey[] = [
  {
    id: 'survey-1',
    title: 'Store Safety Audit',
    description: 'Comprehensive safety audit for retail locations',
    version: 1,
    frequency: AuditFrequency.WEEKLY,
    sections: [
      {
        id: 'section-1',
        title: 'Fire Safety',
        description: 'Fire safety equipment and procedures',
        order: 1,
        questions: [
          {
            id: 'q1',
            text: 'Are fire extinguishers properly mounted and accessible?',
            type: QuestionType.YES_NO,
            required: true,
            order: 1,
            isWeighted: true,
            yesWeight: 5,
            noWeight: 0,
          },
          {
            id: 'q2',
            text: 'Are emergency exits clearly marked and unobstructed?',
            type: QuestionType.YES_NO,
            required: true,
            order: 2,
            isWeighted: true,
            yesWeight: 5,
            noWeight: 0,
          },
        ],
      },
      {
        id: 'section-2',
        title: 'Customer Safety',
        description: 'Customer safety measures and protocols',
        order: 2,
        questions: [
          {
            id: 'q3',
            text: 'Are walkways clear of obstacles and spills?',
            type: QuestionType.YES_NO,
            required: true,
            order: 1,
            isWeighted: true,
            yesWeight: 5,
            noWeight: 0,
          },
          {
            id: 'q4',
            text: 'Is adequate lighting provided throughout the store?',
            type: QuestionType.YES_NO,
            required: true,
            order: 2,
            isWeighted: true,
            yesWeight: 5,
            noWeight: 0,
          },
        ],
      },
    ],
    createdBy: 'user-3',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    isActive: true,
  },
];

// Mock Audits - Cleared, will be created dynamically
export const mockAudits: Audit[] = [];

// Mock Activity Logs - Cleared, will be created dynamically
export const mockActivityLogs: LogEntry[] = [];

// Utility: Clear all mock data
export function clearAllMockData() {
  mockAudits.length = 0
  mockActivityLogs.length = 0
  mockNotifications.length = 0
  mockReviewLocks.length = 0
  console.log('ðŸ§¹ All mock data cleared')
}

// Helper: append activity log
function addLog(
  userId: string,
  action: string,
  details: string,
  entityType: 'audit' | 'survey' | 'user' | 'branch' | 'organization',
  entityId: string
) {
  mockActivityLogs.unshift({
    id: `log-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
    userId,
    action,
    details,
    entityType,
    entityId,
    timestamp: new Date(),
  });
}

// Initialize notifications for existing SUBMITTED audits
function initializeNotificationsForSubmittedAudits() {
  console.log('ðŸ” Checking for SUBMITTED audits to create notifications...')
  console.log(`Total audits: ${mockAudits.length}`)
  
  const submittedAudits = mockAudits.filter(a => a.status === AuditStatus.SUBMITTED)
  console.log(`SUBMITTED audits: ${submittedAudits.length}`, submittedAudits.map(a => a.id))
  
  mockAudits.forEach(audit => {
    if (audit.status !== AuditStatus.SUBMITTED) return
    if (!audit.submittedAt) {
      console.log(`âš ï¸ Audit ${audit.id} is SUBMITTED but has no submittedAt date`)
      return
    }
    
    // Check if notification already exists for this audit
    const existingNotification = mockNotifications.find(
      n => n.relatedId === audit.id && n.actionType === 'REVIEW_AUDIT'
    )
    
    if (existingNotification) {
      console.log(`â„¹ï¸ Notification already exists for audit ${audit.id}`)
      return // Already has notification
    }
    
    // Find branch managers for this branch
    const assignments = mockBranchManagerAssignments.filter(
      assignment => assignment.branchId === audit.branchId && assignment.isActive
    )
    
    console.log(`Branch ${audit.branchId} has ${assignments.length} active managers`, assignments.map(a => a.managerId))
    
    if (assignments.length === 0) {
      console.log(`âš ï¸ No managers assigned to branch ${audit.branchId}`)
      return // No managers assigned
    }
    
    // Get branch name
    const branch = mockBranches.find(b => b.id === audit.branchId)
    const branchName = branch?.name || 'Unknown Branch'
    
    // Get auditor name
    const auditor = mockUsers.find(u => u.id === audit.assignedTo)
    const auditorName = auditor?.name || auditor?.email || 'Unknown Auditor'
    
    // Create notification for each manager
    assignments.forEach(assignment => {
      const notification: Notification = {
        id: `notification-init-${audit.id}-${assignment.managerId}`,
        userId: assignment.managerId,
        type: NotificationType.AUDIT_SUBMITTED,
        title: 'âœ… Audit Submitted for Approval',
        message: `${auditorName} submitted an audit for ${branchName}`,
        link: `/audits/${audit.id}/summary`,
        relatedId: audit.id,
        requiresAction: true,
        actionType: 'REVIEW_AUDIT',
        isRead: false,
        createdAt: audit.submittedAt || new Date(),
      }
      mockNotifications.push(notification)
      console.log(`âœ… Created notification for manager ${assignment.managerId} (${auditor?.email}) for audit ${audit.id}`)
    })
  })
  
  console.log(`ðŸ“Š Total notifications now: ${mockNotifications.length}`)
}

// Call initialization when module loads (ONLY when using mock backend)
// Disabled: Using Supabase backend now
// initializeNotificationsForSubmittedAudits()

// Scheduling helpers
function startOfDay(d: Date): Date {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0)
}
function endOfDay(d: Date): Date {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999)
}
function startOfWeekGeneric(d: Date, weekStartsOn: 0 | 1 = 1): Date {
  const day = d.getDay() // 0=Sun..6=Sat
  const diff = (day - weekStartsOn + 7) % 7
  const s = new Date(d)
  s.setDate(d.getDate() - diff)
  s.setHours(0, 0, 0, 0)
  return s
}
function endOfWeekGeneric(d: Date, weekStartsOn: 0 | 1 = 1): Date {
  const s = startOfWeekGeneric(d, weekStartsOn)
  const e = new Date(s)
  e.setDate(s.getDate() + 6)
  e.setHours(23, 59, 59, 999)
  return e
}
function startOfMonth(d: Date): Date {
  return new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0)
}
function endOfMonth(d: Date): Date {
  return new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999)
}
function startOfQuarter(d: Date): Date {
  const q = Math.floor(d.getMonth() / 3)
  return new Date(d.getFullYear(), q * 3, 1, 0, 0, 0, 0)
}
function endOfQuarter(d: Date): Date {
  const q = Math.floor(d.getMonth() / 3)
  return new Date(d.getFullYear(), (q + 1) * 3, 0, 23, 59, 59, 999)
}
function getOrgLocalNow(org: Organization, now: Date): Date {
  try {
    return new Date(now.toLocaleString('en-US', { timeZone: org.timeZone || 'UTC' }))
  } catch {
    return new Date(now) // fallback
  }
}
function adjustToUTCFromOrgLocal(orgLocal: Date, orgLocalNow: Date, now: Date): Date {
  // map org-local timestamp to UTC by preserving the delta to the real now
  const delta = orgLocalNow.getTime() - now.getTime()
  return new Date(orgLocal.getTime() - delta)
}
function getPeriodRangeForOrg(freq: AuditFrequency, now: Date, org: Organization): { start: Date; end: Date } {
  const orgNow = getOrgLocalNow(org, now)
  let localStart: Date
  let localEnd: Date
  switch (freq) {
    case AuditFrequency.DAILY:
      localStart = startOfDay(orgNow)
      localEnd = endOfDay(orgNow)
      break
    case AuditFrequency.WEEKLY: {
      const w = (org.weekStartsOn ?? 1) as 0 | 1
      localStart = startOfWeekGeneric(orgNow, w)
      localEnd = endOfWeekGeneric(orgNow, w)
      break
    }
    case AuditFrequency.MONTHLY:
      localStart = startOfMonth(orgNow)
      localEnd = endOfMonth(orgNow)
      break
    case AuditFrequency.QUARTERLY:
      localStart = startOfQuarter(orgNow)
      localEnd = endOfQuarter(orgNow)
      break
    default:
      // Default to weekly when unspecified
      const w = (org.weekStartsOn ?? 1) as 0 | 1
      localStart = startOfWeekGeneric(orgNow, w)
      localEnd = endOfWeekGeneric(orgNow, w)
  }
  return { start: adjustToUTCFromOrgLocal(localStart, orgNow, now), end: adjustToUTCFromOrgLocal(localEnd, orgNow, now) }
}

// effectiveAssigneesForBranch and stablePick helpers were used by legacy scheduling logic.
// They are intentionally removed as audits are scheduled as unassigned at period start now.

// Track last period start per org so manual branch assignments apply only to the current cycle
const lastPeriodStartByOrg: Record<string, string | undefined> = {}

function ensureScheduledForCurrentPeriod(now: Date) {
  // For each active survey with frequency
  // New behavior: schedule audits for ALL branches at period start and leave them UNASSIGNED.
  // Admins can then assign via zones or manual distribution later.
  mockSurveys.forEach((s) => {
    const freq = s.frequency || AuditFrequency.WEEKLY
    if (!s.isActive) return
    mockBranches.forEach((b) => {
      const org = mockOrganizations.find(o => o.id === b.orgId) || mockOrganizations[0]
      const { start, end } = getPeriodRangeForOrg(freq, now, org)
      const startIso = start.toISOString()
      // If we detect a new period for this org, clear manual branch assignments for this org
      const prevStartIso = lastPeriodStartByOrg[org.id]
      if (prevStartIso && prevStartIso !== startIso) {
        mockAuditorAssignments.forEach(a => {
          const u = mockUsers.find(u => u.id === a.userId)
          if (u?.orgId === org.id) {
            a.branchIds = []
          }
        })
      }
      if (!prevStartIso) {
        lastPeriodStartByOrg[org.id] = startIso
      } else if (prevStartIso !== startIso) {
        lastPeriodStartByOrg[org.id] = startIso
      }

      const exists = mockAudits.some(a => a.branchId === b.id && a.surveyId === s.id && a.periodStart && new Date(a.periodStart).getTime() === start.getTime())
      if (!exists) {
        const newAudit: Audit = {
          id: `audit-${Date.now()}-${Math.random().toString(36).slice(2,6)}`,
          orgId: b.orgId,
          branchId: b.id,
          surveyId: s.id,
          surveyVersion: s.version,
          assignedTo: '', // unassigned at cycle start
          status: AuditStatus.DRAFT,
          responses: {},
          naReasons: {},
          createdAt: now,
          updatedAt: now,
          periodStart: start,
          periodEnd: end,
          dueAt: end,
          isArchived: false,
        }
        mockAudits.unshift(newAudit)
        addLog('system', 'audit_scheduled_unassigned', `Scheduled ${s.title} for ${b.name} (unassigned)`, 'audit', newAudit.id)
      }
    })
  })
}

function autoArchiveDue(now: Date) {
  mockAudits.forEach((a, idx) => {
    if (a.isArchived) return
    if (a.dueAt && new Date(a.dueAt).getTime() <= now.getTime()) {
      const next: Audit = { ...a, isArchived: true, archivedAt: a.dueAt, updatedAt: now }
      mockAudits[idx] = next
      addLog(a.assignedTo, 'audit_archived_auto', `Archived due audit ${a.id}`, 'audit', a.id)
    }
  })
}

function synchronizeScheduling(now: Date = new Date()) {
  autoArchiveDue(now)
  ensureScheduledForCurrentPeriod(now)
}

// Helper function to get approval authority
function getApprovalAuthority(branchId: string, user: User): ApprovalAuthority {
  // 1. Super Admin can always approve (highest priority)
  if (user.role === UserRole.SUPER_ADMIN) {
    return {
      canApprove: true,
      authority: 'super_admin_override',
      reason: 'Super admin has universal approval authority',
      context: 'Super admin override'
    };
  }
  
  // 2. Get current branch manager assignments
  const assignedManagers = mockBranchManagerAssignments.filter(
    assignment => assignment.branchId === branchId && assignment.isActive
  );
  const isAssignedManager = assignedManagers.some(assignment => assignment.managerId === user.id);
  
  // 3. Branch has assigned managers
  if (assignedManagers.length > 0) {
    if (isAssignedManager && user.role === UserRole.BRANCH_MANAGER) {
      return {
        canApprove: true,
        authority: 'assigned_manager',
        reason: 'User is assigned as branch manager',
        context: `Assigned manager for branch ${branchId}`
      };
    } else {
      return {
        canApprove: false,
        authority: 'none',
        reason: 'Branch has assigned managers, user is not assigned',
        context: `Branch has ${assignedManagers.length} assigned manager(s)`
      };
    }
  }
  
  // 4. No assigned managers - Admin fallback
  if (user.role === UserRole.ADMIN) {
    return {
      canApprove: true,
      authority: 'admin_fallback',
      reason: 'Admin acting as branch manager (no managers assigned)',
      context: 'Admin fallback - no assigned managers'
    };
  }
  
  // 5. No authority
  return {
    canApprove: false,
    authority: 'none',
    reason: 'Insufficient permissions for approval',
    context: 'User lacks approval authority'
  };
}

// Helper functions for review locks
function createReviewLock(auditId: string, userId: string): AuditReviewLock {
  const now = new Date();
  const lockExpiresAt = new Date(now.getTime() + 15 * 60 * 1000); // 15 minutes
  
  const lock: AuditReviewLock = {
    auditId,
    reviewedBy: userId,
    reviewStartedAt: now,
    lockExpiresAt,
    isActive: true
  };
  
  // Remove any existing locks for this audit
  const existingIndex = mockReviewLocks.findIndex(l => l.auditId === auditId);
  if (existingIndex !== -1) {
    mockReviewLocks.splice(existingIndex, 1);
  }
  
  mockReviewLocks.push(lock);
  return lock;
}

function getActiveReviewLock(auditId: string): AuditReviewLock | null {
  const now = new Date();
  return mockReviewLocks.find(lock => 
    lock.auditId === auditId && 
    lock.isActive && 
    lock.lockExpiresAt.getTime() > now.getTime()
  ) || null;
}

function releaseReviewLock(auditId: string, userId: string): void {
  const lockIndex = mockReviewLocks.findIndex(lock => 
    lock.auditId === auditId && lock.reviewedBy === userId
  );
  if (lockIndex !== -1) {
    mockReviewLocks[lockIndex].isActive = false;
  }
}

// Mock API functions
export const mockApi = {
  // Users
  getUsers: async (): Promise<User[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return mockUsers;
  },

  getUserById: async (id: string): Promise<User | null> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockUsers.find(user => user.id === id) || null;
  },

  setUserSignature: async (id: string, signatureUrl: string | null): Promise<User> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockUsers.findIndex(u => u.id === id)
    if (idx === -1) throw new Error(`User not found: ${id}`)
    const current = mockUsers[idx]
    const next: User = { ...current, signatureUrl: signatureUrl || undefined, updatedAt: new Date() }
    mockUsers[idx] = next
    addLog(id, signatureUrl ? 'signature_set' : 'signature_cleared', signatureUrl ? 'Updated signature image' : 'Cleared signature image', 'user', id)
    return next
  },

  deleteAudit: async (id: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 60));
    const idx = mockAudits.findIndex(a => a.id === id)
    if (idx !== -1) {
      mockAudits.splice(idx, 1)
      addLog('user-3', 'audit_deleted', `Deleted audit ${id}`, 'audit', id)
    }
  },

  setUserAvatar: async (id: string, avatarUrl: string | null): Promise<User> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockUsers.findIndex(u => u.id === id)
    if (idx === -1) throw new Error(`User not found: ${id}`)
    const current = mockUsers[idx]
    const next: User = { ...current, avatarUrl: avatarUrl || undefined, updatedAt: new Date() }
    mockUsers[idx] = next
    addLog(id, avatarUrl ? 'avatar_set' : 'avatar_cleared', avatarUrl ? 'Updated profile image' : 'Cleared profile image', 'user', id)
    return next
  },

  updateUser: async (id: string, updates: Partial<{ name: string; email: string; role: UserRole; isActive: boolean }>): Promise<User> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockUsers.findIndex(u => u.id === id)
    if (idx === -1) throw new Error(`User not found: ${id}`)
    const current = mockUsers[idx]
    const next: User = { ...current, ...updates, updatedAt: new Date() }
    mockUsers[idx] = next
    addLog(id, 'user_updated', `Updated profile for user ${id}`, 'user', id)
    return next
  },

  // Audits
  getAudits: async (filters?: { assignedTo?: string; status?: AuditStatus; branchId?: string; orgId?: string; updatedAfter?: Date; updatedBefore?: Date }): Promise<Audit[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    // synchronize auto-archive and scheduling before returning
    synchronizeScheduling(new Date())
    // Ensure notifications exist for submitted audits
    initializeNotificationsForSubmittedAudits()
    let filteredAudits = [...mockAudits];
    
    if (filters?.assignedTo) {
      filteredAudits = filteredAudits.filter(audit => audit.assignedTo === filters.assignedTo);
    }
    
    if (filters?.status) {
      filteredAudits = filteredAudits.filter(audit => audit.status === filters.status);
    }
    if (filters?.branchId) {
      filteredAudits = filteredAudits.filter(audit => audit.branchId === filters.branchId);
    }
    if (filters?.orgId) {
      filteredAudits = filteredAudits.filter(audit => audit.orgId === filters.orgId);
    }
    if (filters?.updatedAfter) {
      const after = filters.updatedAfter.getTime();
      filteredAudits = filteredAudits.filter(audit => new Date(audit.updatedAt).getTime() >= after);
    }
    if (filters?.updatedBefore) {
      const before = filters.updatedBefore.getTime();
      filteredAudits = filteredAudits.filter(audit => new Date(audit.updatedAt).getTime() <= before);
    }
    
    return filteredAudits;
  },

  getAuditById: async (id: string): Promise<Audit | null> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockAudits.find(audit => audit.id === id) || null;
  },

  // Surveys
  getSurveys: async (): Promise<Survey[]> => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return mockSurveys;
  },

  getSurveyById: async (id: string): Promise<Survey | null> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockSurveys.find(survey => survey.id === id) || null;
  },

  // Organizations
  getOrganizations: async (): Promise<Organization[]> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return mockOrganizations;
  },

  updateOrganization: async (id: string, updates: Partial<Pick<Organization, 'name' | 'description' | 'timeZone' | 'weekStartsOn' | 'gatingPolicy'>>): Promise<Organization> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockOrganizations.findIndex(o => o.id === id)
    if (idx === -1) throw new Error(`Organization not found: ${id}`)
    const current = mockOrganizations[idx]
    const next: Organization = { ...current, ...updates, updatedAt: new Date() }
    mockOrganizations[idx] = next
    addLog('system', 'org_updated', `Updated organization ${id}`, 'organization', id)
    return next
  },

  // Branches
  getBranches: async (orgId?: string): Promise<Branch[]> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return orgId 
      ? mockBranches.filter(branch => branch.orgId === orgId)
      : mockBranches;
  },

  // Zones
  getZones: async (orgId?: string): Promise<Zone[]> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return orgId ? mockZones.filter(z => z.orgId === orgId) : mockZones
  },

  createZone: async (payload: Pick<Zone, 'orgId' | 'name' | 'description' | 'branchIds'>): Promise<Zone> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const now = new Date()
    const zone: Zone = { id: `zone-${Date.now()}`, orgId: payload.orgId, name: payload.name, description: payload.description, branchIds: payload.branchIds || [], createdAt: now, updatedAt: now }
    mockZones.unshift(zone)
    addLog('system', 'zone_created', `Created zone ${zone.name}`, 'organization', zone.id)
    return zone
  },

  updateZone: async (id: string, updates: Partial<Pick<Zone, 'name' | 'description' | 'branchIds'>>): Promise<Zone> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockZones.findIndex(z => z.id === id)
    if (idx === -1) throw new Error(`Zone not found: ${id}`)
    const current = mockZones[idx]
    const next: Zone = { ...current, ...updates, updatedAt: new Date() }
    mockZones[idx] = next
    addLog('system', 'zone_updated', `Updated zone ${id}`, 'organization', id)
    return next
  },

  deleteZone: async (id: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockZones.findIndex(z => z.id === id)
    if (idx !== -1) {
      const z = mockZones.splice(idx, 1)[0]
      addLog('system', 'zone_deleted', `Deleted zone ${z.name}`, 'organization', id)
    }
  },

  // Branch CRUD + settings
  createBranch: async (payload: Pick<Branch, 'orgId' | 'name' | 'address' | 'managerId'>): Promise<Branch> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const now = new Date()
    const branch: Branch = { id: `branch-${Date.now()}`, orgId: payload.orgId, name: payload.name, address: payload.address, managerId: payload.managerId, createdAt: now, updatedAt: now }
    mockBranches.unshift(branch)
    addLog('system', 'branch_created', `Created branch ${branch.name}`, 'branch', branch.id)
    return branch
  },

  updateBranch: async (id: string, updates: Partial<Pick<Branch, 'name' | 'address' | 'managerId'>>): Promise<Branch> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockBranches.findIndex(b => b.id === id)
    if (idx === -1) throw new Error(`Branch not found: ${id}`)
    const current = mockBranches[idx]
    const next: Branch = { ...current, ...updates, updatedAt: new Date() }
    mockBranches[idx] = next
    addLog('system', 'branch_updated', `Updated branch ${id}`, 'branch', id)
    return next
  },

  deleteBranch: async (id: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockBranches.findIndex(b => b.id === id)
    if (idx !== -1) {
      const b = mockBranches.splice(idx, 1)[0]
      // Remove from zones
      mockZones.forEach(z => { z.branchIds = z.branchIds.filter(bid => bid !== id); z.updatedAt = new Date() })
      addLog('system', 'branch_deleted', `Deleted branch ${b.name}`, 'branch', id)
    }
  },

  setBranchManager: async (branchId: string, managerId: string | null): Promise<Branch> => {
    return mockApi.updateBranch(branchId, { managerId: managerId || undefined })
  },

  // Branch Manager Assignments (new multiple manager system)
  getAllBranchManagerAssignments: async (): Promise<BranchManagerAssignment[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return mockBranchManagerAssignments.filter(assignment => assignment.isActive);
  },

  getBranchManagerAssignments: async (branchId?: string): Promise<BranchManagerAssignment[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return branchId 
      ? mockBranchManagerAssignments.filter(assignment => assignment.branchId === branchId && assignment.isActive)
      : mockBranchManagerAssignments.filter(assignment => assignment.isActive);
  },

  getManagerBranchAssignments: async (managerId: string): Promise<BranchManagerAssignment[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return mockBranchManagerAssignments.filter(assignment => assignment.managerId === managerId && assignment.isActive);
  },

  assignBranchManager: async (branchId: string, managerId: string, assignedBy: string): Promise<BranchManagerAssignment> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Check if assignment already exists
    const existingAssignment = mockBranchManagerAssignments.find(
      assignment => assignment.branchId === branchId && assignment.managerId === managerId && assignment.isActive
    );
    
    if (existingAssignment) {
      throw new Error('Manager is already assigned to this branch');
    }
    
    const now = new Date();
    const newAssignment: BranchManagerAssignment = {
      id: `bma-${Date.now()}`,
      branchId,
      managerId,
      assignedAt: now,
      assignedBy,
      isActive: true
    };
    
    mockBranchManagerAssignments.push(newAssignment);
    addLog(assignedBy, 'branch_manager_assigned', `Assigned manager ${managerId} to branch ${branchId}`, 'branch', branchId);
    return newAssignment;
  },

  unassignBranchManager: async (branchId: string, managerId: string, unassignedBy: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const assignmentIndex = mockBranchManagerAssignments.findIndex(
      assignment => assignment.branchId === branchId && assignment.managerId === managerId && assignment.isActive
    );
    
    if (assignmentIndex === -1) {
      throw new Error('Manager assignment not found');
    }
    
    mockBranchManagerAssignments[assignmentIndex].isActive = false;
    addLog(unassignedBy, 'branch_manager_unassigned', `Unassigned manager ${managerId} from branch ${branchId}`, 'branch', branchId);
  },

  getBranchesForManager: async (managerId: string): Promise<Branch[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const assignments = mockBranchManagerAssignments.filter(
      assignment => assignment.managerId === managerId && assignment.isActive
    );
    const branchIds = assignments.map(assignment => assignment.branchId);
    return mockBranches.filter(branch => branchIds.includes(branch.id));
  },

  getManagersForBranch: async (branchId: string): Promise<User[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const assignments = mockBranchManagerAssignments.filter(
      assignment => assignment.branchId === branchId && assignment.isActive
    );
    const managerIds = assignments.map(assignment => assignment.managerId);
    return mockUsers.filter(user => managerIds.includes(user.id));
  },

  // Approval Authority
  getApprovalAuthority: async (branchId: string, userId: string): Promise<ApprovalAuthority> => {
    await new Promise(resolve => setTimeout(resolve, 100));
    const user = mockUsers.find(u => u.id === userId);
    if (!user) {
      return {
        canApprove: false,
        authority: 'none',
        reason: 'User not found',
        context: 'Invalid user ID'
      };
    }
    return getApprovalAuthority(branchId, user);
  },

  // Review Locks
  createReviewLock: async (auditId: string, userId: string): Promise<AuditReviewLock> => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return createReviewLock(auditId, userId);
  },

  getActiveReviewLock: async (auditId: string): Promise<AuditReviewLock | null> => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return getActiveReviewLock(auditId);
  },

  releaseReviewLock: async (auditId: string, userId: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 100));
    releaseReviewLock(auditId, userId);
  },

  // Survey frequency is handled at the template level

  // Auditor assignments
  getAuditorAssignments: async (): Promise<AuditorAssignment[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return mockAuditorAssignments
  },

  setAuditorAssignment: async (userId: string, payload: { branchIds: string[]; zoneIds: string[] }): Promise<AuditorAssignment> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockAuditorAssignments.findIndex(a => a.userId === userId)
    const next: AuditorAssignment = { userId, branchIds: payload.branchIds || [], zoneIds: payload.zoneIds || [] }
    if (idx === -1) mockAuditorAssignments.push(next)
    else mockAuditorAssignments[idx] = next
    addLog(userId, 'auditor_assigned', `Assigned to ${next.branchIds.length} branches and ${next.zoneIds.length} zones`, 'user', userId)
    return next
  },

  // Activity Logs
  getActivityLogs: async (entityId?: string): Promise<LogEntry[]> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return entityId
      ? mockActivityLogs.filter(log => log.entityId === entityId)
      : mockActivityLogs;
  },

  // Mutations (in-memory)
  createAudit: async (
    payload: { orgId: string; branchId: string; surveyId: string; assignedTo: string }
  ): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const now = new Date();
    const survey = mockSurveys.find(s => s.id === payload.surveyId);
    const org = mockOrganizations.find(o => o.id === payload.orgId) || mockOrganizations[0]
    const freq = survey?.frequency || AuditFrequency.WEEKLY
    const period = getPeriodRangeForOrg(freq, now, org)
    const newAudit: Audit = {
      id: `audit-${Date.now()}`,
      orgId: payload.orgId,
      branchId: payload.branchId,
      surveyId: payload.surveyId,
      surveyVersion: survey?.version ?? 1,
      assignedTo: payload.assignedTo,
      status: AuditStatus.DRAFT,
      responses: {},
      naReasons: {},
      createdAt: now,
      updatedAt: now,
      periodStart: period.start,
      periodEnd: period.end,
      dueAt: period.end,
      isArchived: false,
    };
    mockAudits.unshift(newAudit);
    addLog(payload.assignedTo, 'audit_created', `Created audit ${newAudit.id} for survey ${payload.surveyId}`, 'audit', newAudit.id);
    return newAudit;
  },
  saveAuditProgress: async (
    auditId: string,
    updates: {
      responses?: Record<string, string>;
      naReasons?: Record<string, string>;
      sectionComments?: Record<string, string>;
    }
  ): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    // Block edits when awaiting approval or already approved
    if (current.status === AuditStatus.SUBMITTED || current.status === AuditStatus.APPROVED) {
      return current;
    }
    // Reopen rejected audits to IN_PROGRESS on save; draft moves to IN_PROGRESS on first save
    const nextStatus = (current.status === AuditStatus.DRAFT || current.status === AuditStatus.REJECTED)
      ? AuditStatus.IN_PROGRESS
      : current.status
    const next: Audit = {
      ...current,
      responses: { ...current.responses, ...(updates.responses || {}) },
      naReasons: { ...current.naReasons, ...(updates.naReasons || {}) },
      sectionComments: { ...(current.sectionComments || {}), ...(updates.sectionComments || {}) },
      status: nextStatus,
      updatedAt: new Date(),
    };
    mockAudits[idx] = next;
    addLog(next.assignedTo, 'audit_saved', `Saved progress for audit ${auditId}`, 'audit', auditId);
    return next;
  },

  /**
   * Admin override to edit an audit regardless of status.
   * Useful for correcting Approved/Submitted audits while keeping status intact.
   */
  adminEditAudit: async (
    auditId: string,
    updates: { responses?: Record<string, string>; naReasons?: Record<string, string>; sectionComments?: Record<string, string> },
    adminUserId: string,
  ): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 120));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    // Permission: only admin may perform override edits
    const actor = mockUsers.find(u => u.id === adminUserId)
    if (actor?.role !== UserRole.ADMIN) {
      throw new Error('Permission denied: Only admin can edit approved/submitted audits')
    }
    const next: Audit = {
      ...current,
      responses: { ...current.responses, ...(updates.responses || {}) },
      naReasons: { ...current.naReasons, ...(updates.naReasons || {}) },
      sectionComments: { ...(current.sectionComments || {}), ...(updates.sectionComments || {}) },
      updatedAt: new Date(),
    };
    mockAudits[idx] = next;
    addLog(adminUserId, 'admin_audit_edited', `Admin edited audit ${auditId}`, 'audit', auditId);
    return next;
  },

  /**
   * Reassign all open audits for a branch to a new auditor.
   * Carries progress for DRAFT, IN_PROGRESS, or REJECTED audits by updating assignedTo.
   * Submitted/Approved/Completed are not touched.
   * Returns the number of audits updated.
   */
  reassignOpenAuditsForBranch: async (branchId: string, toUserId: string): Promise<number> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    let updated = 0
    mockAudits.forEach((a, idx) => {
      if (a.branchId !== branchId) return
      if (a.isArchived) return
      if (a.status === AuditStatus.DRAFT || a.status === AuditStatus.IN_PROGRESS || a.status === AuditStatus.REJECTED) {
        const next: Audit = { ...a, assignedTo: toUserId, updatedAt: new Date() }
        mockAudits[idx] = next
        addLog(toUserId, 'audit_reassigned', `Reassigned open audit ${a.id} to new auditor`, 'audit', a.id)
        updated++
      }
    })
    return updated
  },

  /**
   * Batch variant of reassigning open audits for multiple branches.
   * Returns the total number of audits updated.
   */
  reassignOpenAuditsForBranches: async (branchIds: string[], toUserId: string): Promise<number> => {
    let total = 0
    for (const bid of branchIds) {
      total += await mockApi.reassignOpenAuditsForBranch(bid, toUserId)
    }
    return total
  },

  /**
   * Reassign only NOT-STARTED audits (DRAFT) for a branch to a new auditor.
   * Used for zone distribution â€” does not move IN_PROGRESS or REJECTED audits.
   */
  reassignUnstartedAuditsForBranch: async (branchId: string, toUserId: string): Promise<number> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    let updated = 0
    mockAudits.forEach((a, idx) => {
      if (a.branchId !== branchId) return
      if (a.isArchived) return
      if (a.status === AuditStatus.DRAFT) {
        const next: Audit = { ...a, assignedTo: toUserId, updatedAt: new Date() }
        mockAudits[idx] = next
        addLog(toUserId, 'audit_reassigned_unstarted', `Reassigned not-started audit ${a.id} to new auditor`, 'audit', a.id)
        updated++
      }
    })
    return updated
  },

  /**
   * Batch variant: reassign only NOT-STARTED audits (DRAFT) across multiple branches.
   */
  reassignUnstartedAuditsForBranches: async (branchIds: string[], toUserId: string): Promise<number> => {
    let total = 0
    for (const bid of branchIds) {
      total += await mockApi.reassignUnstartedAuditsForBranch(bid, toUserId)
    }
    return total
  },

  /**
   * Set a specific audit's assignee (for open audits only). Used to support Undo.
   */
  setAuditAssignedTo: async (auditId: string, userId: string): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 60));
    const idx = mockAudits.findIndex(a => a.id === auditId)
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`)
    const current = mockAudits[idx]
    // Only allow for non-archived and open statuses
    if (current.isArchived) return current
    if (current.status !== AuditStatus.DRAFT && current.status !== AuditStatus.IN_PROGRESS && current.status !== AuditStatus.REJECTED) {
      return current
    }
    const next: Audit = { ...current, assignedTo: userId, updatedAt: new Date() }
    mockAudits[idx] = next
    addLog(userId, 'audit_assignee_set', `Set assignee for audit ${auditId}`, 'audit', auditId)
    return next
  },

  manualArchiveAudit: async (auditId: string, userId: string): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 120));
    const idx = mockAudits.findIndex(a => a.id === auditId)
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`)
    const current = mockAudits[idx]
    if (current.isArchived) return current
    const now = new Date()
    const next: Audit = { ...current, isArchived: true, archivedAt: now, updatedAt: now }
    mockAudits[idx] = next
    addLog(userId, 'audit_archived_manual', `Manually archived audit ${auditId}`, 'audit', auditId)
    return next
  },

  submitAuditForApproval: async (auditId: string, submittedBy: string): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    // Permission: only the assignee or an admin can submit for approval
    const submitter = mockUsers.find(u => u.id === submittedBy)
    const isAdmin = submitter?.role === UserRole.ADMIN
    const isAssignee = current.assignedTo === submittedBy
    if (!isAdmin && !isAssignee) {
      throw new Error('Permission denied: Only assignee or admin can submit audit for approval')
    }
    if (!(current.status === AuditStatus.IN_PROGRESS || current.status === AuditStatus.COMPLETED)) {
      throw new Error(`Cannot submit audit ${auditId} from status ${current.status}`);
    }
    const next: Audit = { ...current, status: AuditStatus.SUBMITTED, submittedBy, submittedAt: new Date(), updatedAt: new Date() };
    mockAudits[idx] = next;
    addLog(current.assignedTo, 'audit_submitted', `Submitted audit ${auditId} for approval`, 'audit', auditId);
    return next;
  },

  setAuditApproval: async (
    auditId: string,
    payload: { status: 'approved' | 'rejected'; note?: string; userId: string; signatureUrl?: string; signatureType?: 'image' | 'typed' | 'drawn'; approvalName?: string }
  ): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    
    // Check if audit is in submitted state
    if (current.status !== AuditStatus.SUBMITTED) {
      throw new Error('Audit must be in submitted state to approve/reject');
    }
    
    // Check for active review lock by someone else
    const activeLock = getActiveReviewLock(auditId);
    if (activeLock && activeLock.reviewedBy !== payload.userId) {
      const reviewer = mockUsers.find(u => u.id === activeLock.reviewedBy);
      throw new Error(`Audit is being reviewed by ${reviewer?.name || activeLock.reviewedBy}`);
    }
    
    // Check approval authority using new logic
    const actor = mockUsers.find(u => u.id === payload.userId);
    if (!actor) {
      throw new Error('User not found');
    }
    
    const authority = getApprovalAuthority(current.branchId, actor);
    if (!authority.canApprove) {
      throw new Error(`Permission denied: ${authority.reason}`);
    }
    
    // Get current branch manager assignments for audit trail
    const assignedManagers = mockBranchManagerAssignments.filter(
      assignment => assignment.branchId === current.branchId && assignment.isActive
    );
    const assignedManagerIds = assignedManagers.map(assignment => assignment.managerId);
    const next: Audit = { ...current };
    if (payload.status === 'approved') {
      next.status = AuditStatus.APPROVED;
      next.approvedBy = payload.userId;
      next.approvedAt = new Date();
      next.approvalNote = payload.note || '';
      next.approvalSignatureUrl = payload.signatureUrl;
      next.approvalSignatureType = payload.signatureType;
      next.approvalName = payload.approvalName;
      // New audit trail fields (only set for approvals)
      next.approvalAuthority = authority.authority === 'none' ? undefined : authority.authority;
      next.approvalContext = authority.context;
      next.wasManagerAssignedAtApproval = assignedManagerIds.length > 0;
      next.assignedManagerIdsAtApproval = assignedManagerIds;
      // clear rejection metadata
      next.rejectedBy = undefined;
      next.rejectedAt = undefined;
      next.rejectionNote = undefined;
      addLog(payload.userId, 'audit_approved', `${payload.note || 'Approved'} (${authority.context})`, 'audit', auditId);
    } else {
      next.status = AuditStatus.REJECTED;
      next.rejectedBy = payload.userId;
      next.rejectedAt = new Date();
      next.rejectionNote = payload.note || '';
      // clear approval metadata
      next.approvedBy = undefined;
      next.approvedAt = undefined;
      next.approvalNote = undefined;
      addLog(payload.userId, 'audit_rejected', payload.note || 'Rejected', 'audit', auditId);
    }
    next.updatedAt = new Date();
    mockAudits[idx] = next;
    
    // Release any review lock
    releaseReviewLock(auditId, payload.userId);
    
    return next;
  },

  setAuditStatus: async (auditId: string, status: AuditStatus): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    const next: Audit = { ...current, status, updatedAt: new Date() };
    mockAudits[idx] = next;
    addLog(current.assignedTo, 'audit_status_changed', `Status changed to ${status}`, 'audit', auditId);
    return next;
  },

  setOverrideScore: async (
    auditId: string,
    questionId: string,
    points: number,
    note: string,
    userId: string,
  ): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 120));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    const next: Audit = {
      ...current,
      overrideScores: { ...(current.overrideScores || {}), [questionId]: points },
      overrideNotes: { ...(current.overrideNotes || {}), [questionId]: note },
      updatedAt: new Date(),
    };
    mockAudits[idx] = next;
    addLog(userId, 'na_override_set', `Override set for ${questionId}: ${points} pts`, 'audit', auditId);
    return next;
  },

  // Surveys CRUD (in-memory mocks)
  createSurvey: async (
    payload: Pick<Survey, 'title' | 'description' | 'sections' | 'createdBy'>
  ): Promise<Survey> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const now = new Date();
    const newSurvey: Survey = {
      id: `survey-${Date.now()}`,
      title: payload.title,
      description: payload.description,
      sections: payload.sections || [],
      version: 1,
      frequency: AuditFrequency.WEEKLY,
      createdBy: payload.createdBy,
      createdAt: now,
      updatedAt: now,
      isActive: true,
    };
    mockSurveys.unshift(newSurvey);
    addLog(payload.createdBy, 'survey_created', `Created survey ${newSurvey.title}`, 'survey', newSurvey.id);
    return newSurvey;
  },

  updateSurvey: async (
    id: string,
    updates: Partial<Pick<Survey, 'title' | 'description' | 'sections' | 'isActive' | 'frequency'>>
  ): Promise<Survey> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const idx = mockSurveys.findIndex(s => s.id === id);
    if (idx === -1) throw new Error(`Survey not found: ${id}`);
    const current = mockSurveys[idx];
    const sectionsChanged = updates.sections !== undefined;
    const next: Survey = {
      ...current,
      ...updates,
      version: sectionsChanged ? current.version + 1 : current.version,
      updatedAt: new Date(),
    };
    mockSurveys[idx] = next;
    addLog(current.createdBy, 'survey_updated', `Updated survey ${id}${sectionsChanged ? ' (version bumped)' : ''}`, 'survey', id);
    return next;
  },

  deleteSurvey: async (id: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const idx = mockSurveys.findIndex(s => s.id === id);
    if (idx !== -1) {
      const removed = mockSurveys.splice(idx, 1)[0];
      addLog(removed.createdBy, 'survey_deleted', `Deleted survey ${removed.title}`, 'survey', id);
    }
  },

  duplicateSurvey: async (id: string, createdBy: string): Promise<Survey> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    const original = mockSurveys.find(s => s.id === id);
    if (!original) throw new Error(`Survey not found: ${id}`);
    const now = new Date();
    const copy: Survey = {
      ...original,
      id: `survey-${Date.now()}`,
      title: `${original.title} (Copy)`,
      version: 1,
      frequency: original.frequency,
      createdBy,
      createdAt: now,
      updatedAt: now,
      isActive: true,
    };
    mockSurveys.unshift(copy);
    addLog(createdBy, 'survey_duplicated', `Duplicated survey ${original.title}`, 'survey', copy.id);
    return copy;
  },

  // Section-level attachments & comments
  addSectionPhoto: async (
    auditId: string,
    sectionId: string,
    payload: { filename: string; url: string; uploadedBy: string }
  ): Promise<AuditPhoto> => {
    await new Promise(resolve => setTimeout(resolve, 150));
    const audit = mockAudits.find(a => a.id === auditId);
    if (!audit) throw new Error(`Audit not found: ${auditId}`);
    const photo: AuditPhoto = {
      id: `photo-${Date.now()}`,
      auditId,
      sectionId,
      filename: payload.filename,
      url: payload.url,
      uploadedBy: payload.uploadedBy,
      uploadedAt: new Date(),
    };
    if (!audit.sectionPhotos) audit.sectionPhotos = [];
    audit.sectionPhotos.unshift(photo);
    audit.updatedAt = new Date();
    addLog(audit.assignedTo, 'photo_added', `Added photo ${photo.filename} to section ${sectionId}`, 'audit', auditId);
    return photo;
  },

  removeSectionPhoto: async (auditId: string, photoId: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 120));
    const audit = mockAudits.find(a => a.id === auditId);
    if (!audit) throw new Error(`Audit not found: ${auditId}`);
    if (audit.sectionPhotos) {
      const idx = audit.sectionPhotos.findIndex(p => p.id === photoId);
      if (idx !== -1) audit.sectionPhotos.splice(idx, 1);
    }
    audit.updatedAt = new Date();
    addLog(audit.assignedTo, 'photo_removed', `Removed photo ${photoId}`, 'audit', auditId);
  },

  setSectionComment: async (auditId: string, sectionId: string, comment: string): Promise<Audit> => {
    await new Promise(resolve => setTimeout(resolve, 120));
    const idx = mockAudits.findIndex(a => a.id === auditId);
    if (idx === -1) throw new Error(`Audit not found: ${auditId}`);
    const current = mockAudits[idx];
    const next: Audit = {
      ...current,
      sectionComments: { ...(current.sectionComments || {}), [sectionId]: comment },
      updatedAt: new Date(),
    };
    mockAudits[idx] = next;
    addLog(next.assignedTo, 'section_comment_set', `Updated comment for section ${sectionId}`, 'audit', auditId);
    return next;
  },

  // Notifications
  getNotifications: async (userId: string): Promise<Notification[]> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    console.log(`ðŸ”” getNotifications called for user: ${userId}`)
    console.log(`ðŸ“Š Total mockNotifications before init: ${mockNotifications.length}`)
    // Ensure notifications exist for submitted audits before returning
    initializeNotificationsForSubmittedAudits()
    console.log(`ðŸ“Š Total mockNotifications after init: ${mockNotifications.length}`)
    const userNotifications = mockNotifications.filter(n => n.userId === userId)
    console.log(`ðŸ“¬ Notifications for user ${userId}: ${userNotifications.length}`, userNotifications.map(n => ({id: n.id, title: n.title, userId: n.userId})))
    return userNotifications.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  },

  getUnreadNotificationCount: async (userId: string): Promise<number> => {
    await new Promise(resolve => setTimeout(resolve, 60));
    return mockNotifications.filter(n => n.userId === userId && !n.isRead).length;
  },

  markNotificationAsRead: async (notificationId: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    const notification = mockNotifications.find(n => n.id === notificationId);
    if (notification) {
      notification.isRead = true;
      notification.readAt = new Date();
    }
  },

  markAllNotificationsAsRead: async (userId: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 100));
    const now = new Date();
    mockNotifications
      .filter(n => n.userId === userId && !n.isRead)
      .forEach(n => {
        n.isRead = true;
        n.readAt = now;
      });
  },

  deleteNotification: async (notificationId: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    const idx = mockNotifications.findIndex(n => n.id === notificationId);
    if (idx !== -1) {
      mockNotifications.splice(idx, 1);
    }
  },

  createNotification: async (notification: {
    userId: string;
    type: string;
    title: string;
    message: string;
    link?: string;
    relatedId?: string;
    requiresAction?: boolean;
    actionType?: string;
  }): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    const newNotification: Notification = {
      id: `notification-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      userId: notification.userId,
      type: notification.type as NotificationType,
      title: notification.title,
      message: notification.message,
      link: notification.link,
      relatedId: notification.relatedId,
      requiresAction: notification.requiresAction || false,
      actionType: notification.actionType,
      isRead: false,
      createdAt: new Date(),
    };
    mockNotifications.unshift(newNotification);
  },

  completeNotificationAction: async (relatedId: string, actionType: string): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, 80));
    const notificationsToComplete = mockNotifications.filter(
      n => n.relatedId === relatedId && n.actionType === actionType && !n.actionCompletedAt
    );
    notificationsToComplete.forEach(n => {
      n.actionCompletedAt = new Date();
      n.isRead = true;
      n.readAt = new Date();
    });
  },
};
